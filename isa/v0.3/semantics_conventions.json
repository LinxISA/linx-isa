{
  "version": "v0.3",
  "notes": [
    "This file records staged bring-up semantics conventions that are consumed by the Sail formal model and referenced by the manual.",
    "These conventions are normative for the strict-v0.3 bring-up profile unless overridden by a later revision."
  ],
  "regdst_writeback": {
    "description": "Destination selector semantics for RegDst-like fields that can target GPRs or ClockHands pushes.",
    "no_output": {
      "codes": [
        0,
        [24, 29]
      ],
      "behavior": "No architectural output is produced (silent drop). No exception is raised."
    },
    "gpr": {
      "codes": [
        [1, 23]
      ],
      "behavior": "Write the selected GPR (R1..R23)."
    },
    "clockhands": {
      "u_selector": {
        "code": 30,
        "behavior": "Push result into U-hand queue (u#1..u#4)."
      },
      "t_selector": {
        "code": 31,
        "behavior": "Push result into T-hand queue (t#1..t#4)."
      }
    }
  },
  "srcrtype": {
    "description": "2-bit SrcRType mapping and evaluation order.",
    "mapping": {
      "00": "none",
      "01": "sw (sext32)",
      "10": "uw (zext32)",
      "11": "neg (arithmetic families) / not (logical families)"
    },
    "order": "Apply SrcRType first, then apply any explicit shift (e.g. <<<shamt or <<shamt in addressing).",
    "word_ops": "For *W (32-bit) operations, apply modifiers at 32-bit width, compute a 32-bit result, then sign-extend to 64-bit.",
    "restricted_forms": {
      "description": "For forms whose assembly syntax only allows {.sw,.uw} (e.g. CMP.{EQ,NE,LT,GE,LTU,GEU} and SETC.{EQ,NE,LT,GE,LTU,GEU}), SrcRType=11 is treated as 00 (no modifier) in strict v0.3.",
      "policy": "11_as_00"
    }
  },
  "shifts": {
    "description": "Shift amount masking conventions.",
    "reg_shifts": {
      "xlen64": "mask shift amount to SrcR[5:0] (mod 64)",
      "word32": "mask shift amount to SrcR[4:0] (mod 32)"
    }
  },
  "setc_immediates": {
    "description": "Immediate-compare conventions for SETC.*I forms with an encoded shamt field.",
    "encoding": "SETC.*I encodes simm/uimm plus a 5-bit shamt (bits[11:7] in 32-bit forms, analogous position in HL forms).",
    "semantics": {
      "signed": "imm = SignExtend(simm) << shamt",
      "unsigned": "imm = ZeroExtend(uimm) << shamt"
    },
    "assembly": "Assembly syntax elides shamt (prints a single immediate). Assembler/tooling may choose shamt to represent larger aligned constants when encodable."
  },
  "block_legality": {
    "description": "Legality conventions for which instruction families may appear as payload in coupled scalar blocks vs engine bodies.",
    "bru_control_transfer": {
      "description": "BRU control-transfer instructions (B.* / J / JR / etc.) are not legal payload in coupled scalar blocks; they are vec-engine scalar-lane-only.",
      "on_scalar_block_execute": {
        "trapnum": 4,
        "name": "ILLEGAL_INST",
        "note": "Cause/arg payload TBD; strict profile at minimum traps with TRAPNUM=4."
      },
      "vec_engine_scalar_lane": {
        "pc_domain": "TPC",
        "pc_relative": {
          "offset_unit_bytes": 2,
          "rule": "target = base + (SignExtend(offset) << 1)",
          "base": "TPC (current instruction TPC)",
          "note": "Base is current-instruction TPC (not next-TPC).",
          "jr_rule": "JR target = SrcL + (SignExtend(simm12) << 1)",
          "jr_alignment": "No forced alignment; odd target is permitted (subsequent fetch may fault).",
          "tpc_misalignment_fault": {
            "trapnum": 5,
            "name": "BLOCK_TRAP",
            "e_block": "EC_BFETCH (0x3)",
            "bi": 1,
            "traparg0": "faulting TPC (VA)",
            "note": "Use E_BLOCK(EC_BFETCH) for non-MMU body fetch faults (alignment)."
          }
        },
        "predicate_register": {
          "name": "p",
          "domain": "vec engine predicate register",
          "truth_rule": "p != 0",
          "bz": "taken iff p == 0",
          "bnz": "taken iff p != 0",
          "note": "The predicate domain is vec-engine-defined; any architectural mirroring through BARG/EBARG is profile-defined and should not be assumed by scalar-only components."
        },
        "note": "When executed in the vec engine scalar lane, BRU control-transfer updates the body-local TPC (not architectural global PC)."
      }
    }
  },
  "bitfields": {
    "description": "Bitfield operations (BXS/BXU/CLZ/CTZ/BCNT/BIC/BIS/REV) parameter mapping and wrap-around semantics.",
    "mapping": {
      "M": "imms (or immr for REV)",
      "Nminus1": "imml",
      "N": "imml + 1 (range 1..64)"
    },
    "wrap_around": "Bit ranges are defined on a 64-bit ring. For i=0..N-1, field[i] = SrcL[(M + i) mod 64]. Equivalent: field = ROR64(SrcL, M) & mask_low(N).",
    "alias": {
      "ROR": "Alias of BXU with Nminus1=63 (N=64): ROR64(SrcL, M)."
    },
    "rev": {
      "description": "REV performs byte-order reversal on the selected bitfield.",
      "operation": "field = bitfield_wrap(SrcL, M, N); if (N % 8) != 0 then result=0 else reverse byte order of low N bits; high bits are zero.",
      "invalid_n": "If N is not a multiple of 8, the result is 0 (silent)."
    }
  }
}
